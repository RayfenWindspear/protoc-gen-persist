---
layout: home
---

## About protoc-gen-persist
protoc-gen-persist was created to allow services to abstract away their persistence layer.
Instead of setting up postgres, or mysql and using it in your service directly,  you can now
just make a grpc client that can talk to a generated service that knows how to talk to the database
based on the proto file you generate it from.

Having this generated persistence layer makes changing databases less of a headache, allows horizontal scaling of
your persistence layer, and gets rid of error prone code for simple database calls.

## (Brief) Description
You create the generated code by running protoc, giving it the ```--persist_out``` option.

What is generated is a when running protoc with the ```persist_out``` option is grpc handler functions (written in go)
that parse your grpc requests, and perform the provided query on the database, using the protobuf request struct as parameters.
The result of the query is then marshaled into your grpc response struct and returned. So as a simple example, if you had
the proto file "simple_service.proto":

```protobuf
// we only support proto3 syntax
syntax = "proto3";

package simple_example;

import "github.com/tcncloud/protoc-gen-persist/persist/options.proto";

// a User is row our database's user table
message User {
  int64 id = 1;
  string first_name = 2;
  string last_name = 3;
}

message Id {
  int64 id = 1;
}

service UsersTalker {
  // for this example we will be using a SQL back end instead of a SPANNER back end
  option (persist.service_type) = SQL;

  // we will provide through grpc an Id, and expect back a User
  rpc SelectById(Id) returns (User) {
    option (persist.ql) = {
      // the query to run,  and the arguments to use. ?  will be replaced with the "id" field of the request
      query: "SELECT * from users WHERE id=? LIMIT 1"
      arguments: ["id"]
    };
  };
}

```
run the protoc commands (in the directory with the proto file):
- ```protoc -I/usr/local/include -I. -I$GOPATH/src --go_out=plugins=grpc:. ./simple_service.proto```
- ```protoc -I/usr/local/include -I. -I$GOPATH/src --persist_out=plugins=protoc-gen-persist:. ./simple_service.proto```

two new files (per proto file)  will be generated:
- simple_service.pb.go (from your --go_out command)
- simple_service.persist.go (from --persist_out command)

the .pb.go file will have your grpc service definition, and all the go types for your proto message definitions.
the .persist.go wil have your database handlers, and service implementation for talking with your persistence layer.
This example would generate a simple_service.persist.go file that looks like this:
```go
// This file is generated by protoc-gen-persist
// Source File: simple_service.proto
// DO NOT EDIT !
package simple_example

import (
	sql "database/sql"
	strings "strings"

	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

type UsersTalkerImpl struct {
	SqlDB *sql.DB
}

func NewUsersTalkerImpl(driver, connString string) (*UsersTalkerImpl, error) {
	db, err := sql.Open(driver, connString)
	if err != nil {
		return nil, err
	}
	return &UsersTalkerImpl{SqlDB: db}, nil
}

// sql unary SelectById
func (s *UsersTalkerImpl) SelectById(ctx context.Context, req *Id) (*User, error) {
	var (
		FirstName string
		Id        int64
		LastName  string
	)
	err := s.SqlDB.QueryRow("SELECT * from users WHERE id=? LIMIT 1", req.Id).
		Scan(&Id, &FirstName, &LastName)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, grpc.Errorf(codes.NotFound, "%+v doesn't exist", req)
		} else if strings.Contains(err.Error(), "duplicate key") {
			return nil, grpc.Errorf(codes.AlreadyExists, "%+v already exists")
		}
		return nil, grpc.Errorf(codes.Unknown, err.Error())
	}
	res := &User{

		FirstName: FirstName,
		Id:        Id,
		LastName:  LastName,
	}
	return res, nil
}
```

All that is left to do is to attach a "UsersTalkerImpl" to a grpc service and run it.
Here is a simple example of one way you could do that:
``` go
package main

import (
	"fmt"
	"net"
	_"github.com/go-sql-driver/mysql"
	pb "simple_service" // wherever we put the proto generated code
	"google.golang.org/grpc"
)


func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		panic(err)
	}
	grpcServer := grpc.NewServer()
	s, err := pb.NewUsersTalkerImpl("mysql", "user:password@/dbname")
	if err != nil {
		panic(err)
	}
	pb.RegisterUsersTalkerServer(grpcServer, s)
	fmt.Printf("server listening on 50051\n")
	grpcServer.Serve(lis)
}
```

All that is left to do is build, and run your server. Then you will be able to make a grpc client
that can talk to your grpc server, and get users from the database when sent their id as a grpc call.

Full code examples can be found in the [examples directory](../examples/README.md)

### Constructing Your Proto File
protoc-gen-persist generates code based on how you construct your .proto file.  It generates code
by looking at 4 things on your grpc service:
- request/response message types of the rpc call
- the streaming catagory of the rpc call (none, client streaming, server streaming, bidirectional)
- service level options (type mapping definitions, and sevice type)
- method level options (the query string, and arguments array)

The options will be gone over in more detail in the next section. This section will cover what gets generated
based on the streaming type of your rpc call, and the request/response message types of the rpc call

#### non streaming calls
for non streaming calls ```rpc SelectById(Id) returns (User)```
protoc-gen-persist generates code that assumes the query returns at most one row.
- For sql backends the handler uses database/sql QueryRow method.
- For spanner additional rows are ignored.

#### server streaming call
for server streaming calls: ```rpc SelectByName(Name) returns (stream User)```
protoc gen-persist generates a handler that runs the provided query, and streams
back each result one by one.
- For sql backends  the handler uses database/sql's Query method
- Spanner does a single() read transaction.


Do not use non streaming, or server streaming calls if your query does not return rows.  In the future,
We might try to identify if the query returns rows or not,  and generate code based on that,  but this
is not yet supported.

#### client streaming calls
for client streaming calls: ```rpc InsertUsers(stream User) returns (NumRowsInserted)```
protoc-gen-persist generates a handler begins a transaction,  makes a prepared statement
and executes that statement for every received request over the stream. If an error is encountered,
the transaction is rolled back.  After all requests have been executed on the statment successfully
the transaction is committed, and the number of times the query exectued will be returned. Client streaming
queries assume your message response type  has a count field.  As stated before, your response message can
have additional fields, but the field that is required to be on the response for a client streaming call
is a count field that looks like this ex.
```proto
message NumRows {
  int64 count = 1;
}
```
- For sql service types the streamed reqeusts are executed on the transaction right away, and the error is
checked right away.  It is safe to stream any number of requests over before closing the stream.
- For spanner service types the streamed requests are stored in a slice of mutations.  The mutations are
not applied to the database till the stream is closed by the client.  This is done because there is no rollback
feature for spanner. All mutations given to an apply method are done only if they all succeed. Till there is a
way to have a transaction that can be rolled back in spanner,  be aware that each request is stored as a mutation in
memory on the server.



lets take some proto messages as examples:
```proto
// a User is row our database's user table
message User {
  int64 id = 1;
  string first_name = 2;
  string last_name = 3;
}

message Id {
  int64 id = 1;
}

message NumRows {
  int64 count = 1;
}
```




### Persistance Options

### Spanner Queries

### More Help
This will walk you through step by step creating a project that talks to a users table stored in postgres.

[Tutorial](tutorial.md)


