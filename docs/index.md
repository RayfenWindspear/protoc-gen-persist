---
layout: home
---

## About protoc-gen-persist
protoc-gen-persist was created to allow services to abstract away their persistence layer.
Instead of setting up postgres, or mysql and using it in your service directly,  you can now
just make a grpc client that can talk to a generated service that knows how to talk to the database
based on the proto file you generate it from.

Having this generated persistence layer makes changing databases less of a headache, allows horizontal scaling of
your persistence layer, and gets rid of error prone code for simple database calls.

## (Brief) Description
You create the generated code by running protoc, giving it the ```--persist_out``` option.

What is generated is a when running protoc with the ```persist_out``` option is grpc handler functions (written in go)
that parse your grpc requests, and perform the provided query on the database, using the protobuf request struct as parameters.
The result of the query is then marshaled into your grpc response struct and returned. So as a simple example, if you had
the proto file "simple_service.proto":

```protobuf
// we only support proto3 syntax
syntax = "proto3";

package simple_example;

import "github.com/tcncloud/protoc-gen-persist/persist/options.proto";

// a User is row our database's user table
message User {
  int64 id = 1;
  string first_name = 2;
  string last_name = 3;
}

message Id {
  int64 id = 1;
}

service UsersTalker {
  // for this example we will be using a SQL back end instead of a SPANNER back end
  option (persist.service_type) = SQL;

  // we will provide through grpc an Id, and expect back a User
  rpc SelectById(Id) returns (User) {
    option (persist.ql) = {
      // the query to run,  and the arguments to use. ?  will be replaced with the "id" field of the request
      query: "SELECT * from users WHERE id=? LIMIT 1"
      arguments: ["id"]
    };
  };
}

```
run the protoc commands (in the directory with the proto file):
- ```protoc -I/usr/local/include -I. -I$GOPATH/src --go_out=plugins=grpc:. ./simple_service.proto```
- ```protoc -I/usr/local/include -I. -I$GOPATH/src --persist_out=plugins=protoc-gen-persist:. ./simple_service.proto```

two new files (per proto file)  will be generated:
- simple_service.pb.go (from your --go_out command)
- simple_service.persist.go (from --persist_out command)

the .pb.go file will have your grpc service definition, and all the go types for your proto message definitions.
the .persist.go wil have your database handlers, and service implementation for talking with your persistence layer.
This example would generate a simple_service.persist.go file that looks like this:
```go
// This file is generated by protoc-gen-persist
// Source File: simple_service.proto
// DO NOT EDIT !
package simple_example

import (
	sql "database/sql"
	strings "strings"

	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

type UsersTalkerImpl struct {
	SqlDB *sql.DB
}

func NewUsersTalkerImpl(driver, connString string) (*UsersTalkerImpl, error) {
	db, err := sql.Open(driver, connString)
	if err != nil {
		return nil, err
	}
	return &UsersTalkerImpl{SqlDB: db}, nil
}

// sql unary SelectById
func (s *UsersTalkerImpl) SelectById(ctx context.Context, req *Id) (*User, error) {
	var (
		FirstName string
		Id        int64
		LastName  string
	)
	err := s.SqlDB.QueryRow("SELECT * from users WHERE id=? LIMIT 1", req.Id).
		Scan(&Id, &FirstName, &LastName)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, grpc.Errorf(codes.NotFound, "%+v doesn't exist", req)
		} else if strings.Contains(err.Error(), "duplicate key") {
			return nil, grpc.Errorf(codes.AlreadyExists, "%+v already exists")
		}
		return nil, grpc.Errorf(codes.Unknown, err.Error())
	}
	res := &User{

		FirstName: FirstName,
		Id:        Id,
		LastName:  LastName,
	}
	return res, nil
}
```

All that is left to do is to attach a "UsersTalkerImpl" to a grpc service and run it.
Here is a simple example of one way you could do that assuming you are using a vendor directory:
``` go
package main

import (
	"fmt"
	"net"
	_"github.com/go-sql-driver/mysql"
	pb "simple_service"
	"google.golang.org/grpc"
)


func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		panic(err)
	}
	grpcServer := grpc.NewServer()
	s, err := pb.NewUsersTalkerImpl("mysql", "user:password@/dbname")
	if err != nil {
		panic(err)
	}
	pb.RegisterUsersTalkerServer(grpcServer, s)
	fmt.Printf("server listening on 50051\n")
	grpcServer.Serve(lis)
}
```

That is it.  you simply build, and run your server, and you will be able to make a grpc client
that can talk to your grpc server, and get users when given ids.

Full code examples can be found in the [examples directory](../examples/README.md)


This will walk you through step by step creating a project that talks to a users table stored in postgres.
[Tutorial](tutorial.md)


