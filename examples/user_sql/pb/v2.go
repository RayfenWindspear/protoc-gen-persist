// This file is generated by protoc-gen-persist
// Source File: pb/user.proto
// DO NOT EDIT !
package pb

import (
	sql "database/sql"
	"database/sql/driver"
	"fmt"
	io "io"

	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	context "golang.org/x/net/context"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

type RestOfUServHandlers interface {
	UpdateAllNames(req *Empty, stream UServ_UpdateAllNamesServer) error
}
type UServTypeMapping interface {
	TimestampTimestamp() TimestampTimestampMappingImpl
	SliceStringParam() SliceStringParamMappingImpl
}
type TimestampTimestampMappingImpl interface {
	ToProto(**timestamp.Timestamp) error
	Empty() TimestampTimestampMappingImpl
	ToSql(*timestamp.Timestamp) sql.Scanner
	sql.Scanner
	driver.Valuer
}
type SliceStringParamMappingImpl interface {
	ToProto(**SliceStringParam) error
	Empty() SliceStringParamMappingImpl
	ToSql(*SliceStringParam) sql.Scanner
	sql.Scanner
	driver.Valuer
}
type UServHooks interface {
	InsertUsersBeforeHook(*User) (*Empty, error)
	InsertUsersAfterHook(*User, *Empty) error
	GetAllUsersBeforeHook(*Empty) ([]*User, error)
	GetAllUsersAfterHook(*Empty, *User) error
}
type scanable interface {
	Scan(...interface{}) error
	Columns() ([]string, error)
}
type Runable interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
}

func DefaultClientStreamingPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return db.BeginTx(ctx, nil)
}
func DefaultServerStreamingPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return NopPersistTx(db)
}
func DefaultBidiStreamingPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return NopPersistTx(db)
}
func DefaultUnaryPersistTx(ctx context.Context, db *sql.DB) (PersistTx, error) {
	return NopPersistTx(db)
}

type ignoreTx struct {
	r Runable
}

func (this *ignoreTx) Commit() error   { return nil }
func (this *ignoreTx) Rollback() error { return nil }
func (this *ignoreTx) QueryContext(ctx context.Context, x string, ys ...interface{}) (*sql.Rows, error) {
	return this.r.QueryContext(ctx, x, ys...)
}
func (this *ignoreTx) ExecContext(ctx context.Context, x string, ys ...interface{}) (sql.Result, error) {
	return this.r.ExecContext(ctx, x, ys...)
}

type UServ_QueryOpts struct {
	MAPPINGS *UServTypeMapping
	db       Runable
}

func DefaultUServQueryOpts(db Runable) UServ_QueryOpts {
	return UServ_QueryOpts{
		db: db,
	}
}

type UServ_Queries struct {
	opts UServ_QueryOpts
}
type PersistTx interface {
	Commit() error
	Rollback() error
	Runable
}

func NopPersistTx(r Runable) (PersistTx, error) {
	return &ignoreTx{r}, nil
}

// UServPersistQueries returns all the known 'SQL' queires for the 'UServ' service.
func UServPersistQueries(db Runable, opts ...UServ_QueryOpts) *UServ_Queries {
	var myOpts UServ_QueryOpts
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = DefaultUServQueryOpts(db)
	}
	return &UServ_Queries{
		opts: myOpts,
	}
}

// camel case the services query name
// method for every query

// InsertUsersQuery returns a new struct wrapping the current UServ_QueryOpts
// that will perform 'UServ' services 'insert_users_query' on the database
// when executed
func (this *UServ_Queries) InsertUsersQuery() *UServ_InsertUsersQuery {
	return &UServ_InsertUsersQuery{
		opts: UServ_QueryOpts{
			MAPPINGS: this.opts.MAPPIGNS,
			db:       this.opts.db,
		},
	}
}

// I dont know this is a insert query, I only know this is a query
type UServ_InsertUsersQuery struct {
	opts UServ_QueryOpts
}

type LooksLike_User interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type LooksLike_UserProto struct {
	item LooksLike_User
}

func LooksLikeUser(item LooksLike_User) *LooksLike_UserProto {
	return &LooksLike_UserProto{item}
}
func (this *LooksLike_UserProto) Unwrap() LooksLike_User {
	return this.item
}

// one for each Output type of the methods that use this query + the output proto itself

func (this *LooksLike_UserProto) User() *User {
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}
}

// just for example
func (this *LooksLike_UserProto) Friends() *Friends {
	return nil
}

// the main execute function
func (this *UServ_InsertUsersQuery) Execute(ctx context.Context, x LooksLike_User) *UServ_InsertUsersResult {
	var setupErr error
	params := []interface{}{
		func() (out interface{}) {
			out = x.GetId()
			return
		}(),
		func() (out interface{}) {
			out = x.GetName()
			return
		}(),
		func() (out interface{}) {
			raw, err := proto.Marshal(x.GetFriends())
			if err != nil {
				setupErr = err
			}
			out = raw
			return
		}(),
		func() (out interface{}) {
			mapper := this.opts.MAPPINGS.TimestampTimestamp()
			out = mapper.ToSql(x.GetCreatedOn())
			return
		}(),
	}
	result := &UServ_UnsertUserseResult{
		tm: this.opts.MAPPINGS,
	}
	if setupErr != nil {
		result.err = setupErr
		return result
	}
	result.result, result.err = this.opts.db.ExecContext(ctx, "INSERT INTO users (id, name, friends, created_on) VALUES ($1, $2, $3, $4)", params...)

	return result
}

//<SERVICE><QUERY (camel)><MESSAGE TYPE>RESULT
type UServ_InsertUsersResult struct {
	result sql.Result
	rows   *sql.Rows
	err    error
	tm     UServTypeMapping
}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns ctx.Err() if encountered.
func (this *UServ_InsertUsersResult) Each(ctx context.Context, fun func(*LooksLike_UserProto) error) error {
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			res, err := this.Next()
			if err == io.EOF {
				return nil
			} else if err != nil {
				return err
			}
			if err := fun(res); err != nil {
				return err
			}
		}
	}
	return nil
}

// One returns the sole row, or an error if there was not one result
func (this *UServ_InsertUsersResult) One() (*LooksLike_UserProto, error) {
	first, err := this.Next()
	if err != nil {
		return nil, err
	}
	if _, err := this.Next(); err != io.EOF {
		if err != nil {
			return nil, err
		}
		return nil, fmt.Errorf("expected exactly 1 'User' result from query")
	}
	return first, nil
}

// Zero returns an error if there were any rows in the result
func (this *UServ_InsertUsersResult) Zero() error {
	if _, err := this.Next(); err != io.EOF {
		if err != nil {
			return err
		}
		return fmt.Errorf("expected exactly 0 'User' results from query")
	}
	return nil
}

// Next returns the next scanned row out of the database, or io.EOF if there are no more rows
func (this *UServ_InsertUsersResult) Next() (*LooksLike_UserProto, error) {
	if this.err != nil {
		return nil, this.err
	}
	if this.rows == nil {
		return nil, io.EOF
	}
	cols, err := this.rows.Columns()
	if err != nil {
		return nil, err
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if this.err = this.rows.Scan(toScan...); this.err != nil {
		return nil, this.err
	}
	// this sets the error for next time, after this point,
	// we do not return this.err
	if !this.rows.Next() {
		if this.err = this.rows.Err(); this.err == nil {
			this.err = io.EOF
		}
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return nil, fmt.Errorf("cant convert db column id to protobuf go type int64")
			}
			res.Id = r
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return nil, fmt.Errorf("cant convert db column name to protobuf go type string")
			}
			res.Name = r
		case "friends":
			{
				r, ok := (*scanned[i].i).([]byte)
				if !ok {
					return nil, fmt.Errorf("cant convert db column friends to protobuf go type *Friends")
				}
				var converted = new(Friends)
				if err := proto.Unmarshal(r, converted); err != nil {
					return nil, err
				}
				res.Friends = converted
			}
		case "created_on":
			{
				var converted = this.tm.TimestampTimestamp().Empty()
				if err := converted.Scan(*scanned[i].i); err != nil {
					return nil, fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)
				}
				if err := converted.ToProto(&res.CreatedOn); err != nil {
					return nil, fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)
				}
			}
		default:
			return nil, fmt.Errorf("unsupported column in output: %s", col)
		}
	}
	return &LooksLike_UserProto{item: res}, nil
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_InsertUsersResult) Slice() ([]*LooksLike_UserProto, error) {
	var results []*LooksLike_UserProto
	for {
		i, err := this.Next()
		if err == io.EOF {
			break
		} else if err != nil {
			return nil, err
		}
		results = append(results, i)
	}
	return results, nil
}

// returns the known columns for this result
func (r *UServ_InsertUsersResult) Columns() ([]string, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.rows != nil {
		return r.rows.Columns()
	}
	return nil, nil
}

type UServ_ImplOpts struct {
	MAPPINGS UServTypeMapping
	HOOKS    UServHooks
}

func DefaultUServImplOpts() UServ_ImplOpts {
	return UServ_ImplOpts{}
}

type UServ_Impl struct {
	opts    *UServ_ImplOpts
	QUERIES *UServ_Queries
	DB      *sql.DB
}

func UServPersistImpl(db *sql.DB, opts ...UServ_ImplOpts) *UServ_Impl {
	var myOpts UServ_ImplOpts
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = DefaultUServImplOpts()
	}
	return &UServ_Impl{
		opts:    myOpts,
		QUERIES: UServPersistQueries(UServ_QueryOpts{MAPPINGS: &myOpts.MAPPINGS}),
		DB:      db,
	}
}

// THIS is the grpc handler
func (this *UServ_Impl) InsertUsers(stream UServ_InsertUsersServer) error {
	tx, err := DefaultClientStreamingPersistTx(stream.Context(), this.DB)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error creating persist tx: %v", err)
	}
	if err := this.InsertUsersTx(stream, tx); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'insert_users' query: %v", err)
	}
	return nil
}

func (this *UServ_Impl) InsertUsersTx(stream UServ_InsertUsersServer, tx PersistTx) error {
	query := this.QUERIES.InsertUsersQuery()
	var first *User
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}
		// TODO UPDATE HOOKS FOR CTX
		beforeRes, err := this.opts.HOOKS.InsertUsersBeforeHook( /*stream.Context(),*/ req)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
		} else if beforeRes != nil {
			continue
		}
		result := query.Execute(req)
		// TODO allow results to be returned here?
		if err := result.Zero(); err != nil {
			return gstatus.Errorf(codes.InvalidArgument, "client streaming queries must return zero results")
		}
	}
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("executed 'insert_users' query without error, but received error on commit: %v", err)
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			return fmt.Errorf("error executing 'insert_users' query :::AND COULD NOT ROLLBACK::: rollback err: %v, query err: %v", rollbackErr, err)
		}
	}
	res := &Empty{}
	if err := this.opts.HOOKS.InsertUsersAfterHook( /*stream.Context(),*/ first, res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
	}
	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}

	return nil
}
