// This file is generated by protoc-gen-persist
// Source File: pb/user.proto
// DO NOT EDIT !
package pb

import (
	sql "database/sql"
	fmt "fmt"
	io "io"

	proto "github.com/golang/protobuf/proto"
	persist_lib "github.com/tcncloud/protoc-gen-persist/examples/user_sql/pb/persist_lib"
	context "golang.org/x/net/context"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

type UServImplBuilder struct {
	err           error
	rest          RestOfUServHandlers
	queryHandlers *persist_lib.UServQueryHandlers
	i             *UServ_Impl
	db            *sql.DB
	hooks         UServHooks
	mappings      UServTypeMapping
}

func NewUServBuilder() *UServImplBuilder {
	return &UServImplBuilder{i: &UServ_Impl{}}
}
func (b *UServImplBuilder) WithHooks(hs UServHooks) *UServImplBuilder {
	b.hooks = hs
	return b
}
func (b *UServImplBuilder) WithTypeMapping(ts UServTypeMapping) *UServImplBuilder {
	b.mappings = ts
	return b
}
func (b *UServImplBuilder) WithRestOfGrpcHandlers(r RestOfUServHandlers) *UServImplBuilder {
	b.rest = r
	return b
}
func (b *UServImplBuilder) WithPersistQueryHandlers(p *persist_lib.UServQueryHandlers) *UServImplBuilder {
	b.queryHandlers = p
	return b
}
func (b *UServImplBuilder) WithDefaultQueryHandlers() *UServImplBuilder {
	accessor := persist_lib.NewSqlClientGetter(&b.db)
	queryHandlers := &persist_lib.UServQueryHandlers{
		CreateTableHandler:     persist_lib.DefaultCreateTableHandler(accessor),
		InsertUsersHandler:     persist_lib.DefaultInsertUsersHandler(accessor),
		GetAllUsersHandler:     persist_lib.DefaultGetAllUsersHandler(accessor),
		SelectUserByIdHandler:  persist_lib.DefaultSelectUserByIdHandler(accessor),
		UpdateUserNamesHandler: persist_lib.DefaultUpdateUserNamesHandler(accessor),
		UpdateNameToFooHandler: persist_lib.DefaultUpdateNameToFooHandler(accessor),
		GetFriendsHandler:      persist_lib.DefaultGetFriendsHandler(accessor),
		DropTableHandler:       persist_lib.DefaultDropTableHandler(accessor),
	}
	b.queryHandlers = queryHandlers
	return b
}
func (b *UServImplBuilder) WithNilAsDefaultQueryHandlers(p *persist_lib.UServQueryHandlers) *UServImplBuilder {
	accessor := persist_lib.NewSqlClientGetter(&b.db)
	if p.CreateTableHandler == nil {
		p.CreateTableHandler = persist_lib.DefaultCreateTableHandler(accessor)
	}
	if p.InsertUsersHandler == nil {
		p.InsertUsersHandler = persist_lib.DefaultInsertUsersHandler(accessor)
	}
	if p.GetAllUsersHandler == nil {
		p.GetAllUsersHandler = persist_lib.DefaultGetAllUsersHandler(accessor)
	}
	if p.SelectUserByIdHandler == nil {
		p.SelectUserByIdHandler = persist_lib.DefaultSelectUserByIdHandler(accessor)
	}
	if p.UpdateUserNamesHandler == nil {
		p.UpdateUserNamesHandler = persist_lib.DefaultUpdateUserNamesHandler(accessor)
	}
	if p.UpdateNameToFooHandler == nil {
		p.UpdateNameToFooHandler = persist_lib.DefaultUpdateNameToFooHandler(accessor)
	}
	if p.GetFriendsHandler == nil {
		p.GetFriendsHandler = persist_lib.DefaultGetFriendsHandler(accessor)
	}
	if p.DropTableHandler == nil {
		p.DropTableHandler = persist_lib.DefaultDropTableHandler(accessor)
	}
	b.queryHandlers = p
	return b
}
func (b *UServImplBuilder) WithSqlClient(c *sql.DB) *UServImplBuilder {
	b.db = c
	return b
}
func (b *UServImplBuilder) WithNewSqlDb(driverName, dataSourceName string) *UServImplBuilder {
	db, err := sql.Open(driverName, dataSourceName)
	b.err = err
	if b.err == nil {
		b.db = db
	}
	return b
}
func (b *UServImplBuilder) Build() (*UServ_Impl, error) {
	if b.err != nil {
		return nil, b.err
	}
	b.i.PERSIST = &persist_lib.UServMethodReceiver{Handlers: *b.queryHandlers}
	b.i.FORWARDED = b.rest
	b.i.HOOKS = b.hooks
	b.i.MAPPINGS = b.mappings
	return b.i, nil
}
func (b *UServImplBuilder) MustBuild() *UServ_Impl {
	s, err := b.Build()
	if err != nil {
		panic("error in builder: " + err.Error())
	}
	return s
}
func EmptyToUServPersistType(serv UServTypeMapping, req *Empty) (*persist_lib.EmptyForUServ, error) {
	params := &persist_lib.EmptyForUServ{}
	return params, nil
}
func EmptyFromUServDatabaseRow(serv UServTypeMapping, row persist_lib.Scanable) (*Empty, error) {
	cols, err := row.Columns()
	if err != nil {
		return nil, err
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if err := row.Scan(toScan...); err != nil {
		return nil, err
	}
	res := &Empty{}
	for i, col := range cols {
		_ = i
		switch col {
		default:
			return nil, fmt.Errorf("unsupported column in output: %s", col)
		}
	}
	return res, nil
}
func IterUServEmptyProto(ms UServTypeMapping, iter *persist_lib.Result, next func(i *Empty) error) error {
	return iter.Do(func(r persist_lib.Scanable) error {
		item, err := EmptyFromUServDatabaseRow(ms, r)
		if err != nil {
			return fmt.Errorf("error converting Empty row to protobuf message: %s", err)
		}
		return next(item)
	})
}
func UserToUServPersistType(serv UServTypeMapping, req *User) (*persist_lib.UserForUServ, error) {
	params := &persist_lib.UserForUServ{}
	params.Id = req.Id
	params.Name = req.Name
	if req.Friends == nil {
		req.Friends = new(Friends)
	}
	{
		raw, err := proto.Marshal(req.Friends)
		if err != nil {
			return nil, err
		}
		params.Friends = raw
	}
	{
		mapper := serv.TimestampTimestamp()
		params.CreatedOn = mapper.ToSql(req.CreatedOn)
	}
	return params, nil
}
func UserFromUServDatabaseRow(serv UServTypeMapping, row persist_lib.Scanable) (*User, error) {
	cols, err := row.Columns()
	if err != nil {
		return nil, err
	}
	toScan := make([]interface{}, len(cols))
	scanned := make([]alwaysScanner, len(cols))
	for i := range scanned {
		toScan[i] = &scanned[i]
	}
	if err := row.Scan(toScan...); err != nil {
		return nil, err
	}
	res := &User{}
	for i, col := range cols {
		_ = i
		switch col {
		case "id":
			r, ok := (*scanned[i].i).(int64)
			if !ok {
				return nil, fmt.Errorf("cant convert db column id to protobuf go type int64")
			}
			res.Id = r
		case "name":
			r, ok := (*scanned[i].i).(string)
			if !ok {
				return nil, fmt.Errorf("cant convert db column name to protobuf go type string")
			}
			res.Name = r
		case "friends":
			{
				r, ok := (*scanned[i].i).([]byte)
				if !ok {
					return nil, fmt.Errorf("cant convert db column friends to protobuf go type *Friends")
				}
				var converted = new(Friends)
				if err := proto.Unmarshal(r, converted); err != nil {
					return nil, err
				}
				res.Friends = converted
			}
		case "created_on":
			{
				var converted = serv.TimestampTimestamp().Empty()
				if err := converted.Scan(*scanned[i].i); err != nil {
					return nil, fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)
				}
				if err := converted.ToProto(&res.CreatedOn); err != nil {
					return nil, fmt.Errorf("could not convert mapped db column created_on to type on User.CreatedOn: %v", err)
				}
			}
		default:
			return nil, fmt.Errorf("unsupported column in output: %s", col)
		}
	}
	return res, nil
}
func IterUServUserProto(ms UServTypeMapping, iter *persist_lib.Result, next func(i *User) error) error {
	return iter.Do(func(r persist_lib.Scanable) error {
		item, err := UserFromUServDatabaseRow(ms, r)
		if err != nil {
			return fmt.Errorf("error converting User row to protobuf message: %s", err)
		}
		return next(item)
	})
}

type UServIterators struct {
	ms UServTypeMapping
}

func (this *UServIterators) User(iter *persist_lib.Result, next func(*User) error) error {
	return iter.Do(func(r persist_lib.Scanable) error {
		item, err := UserFromUServDatabaseRow(this.ms, r)
		if err != nil {
			return fmt.Errorf("error converting User row to protobuf message: %s", err)
		}
		return next(item)
	})
}
func (this *UServIterators) Empty(iter *persist_lib.Result, next func(*Empty) error) error {
}

func UServIters(ms UServTypeMapping) UServIterators {
	return UServIterators{ms}

}

func FriendsReqToUServPersistType(serv UServTypeMapping, req *FriendsReq) (*persist_lib.FriendsReqForUServ, error) {
	params := &persist_lib.FriendsReqForUServ{}
	{
		mapper := serv.SliceStringParam()
		params.Names = mapper.ToSql(req.Names)
	}
	return params, nil
}
func (s *UServ_Impl) CreateTable(ctx context.Context, req *Empty) (*Empty, error) {
	var err error
	var res = &Empty{}
	_ = err
	_ = res
	params, err := EmptyToUServPersistType(s.MAPPINGS, req)
	if err != nil {
		return nil, err
	}
	var iterErr error
	err = s.PERSIST.CreateTable(ctx, params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err = EmptyFromUServDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
	})
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error calling persist service: %v", err)
	} else if iterErr != nil {
		return nil, iterErr
	}
	return res, nil
}
func (s *UServ_Impl) InsertUsersOld(stream UServ_InsertUsersServer) error {
	var err error
	_ = err
	res := &Empty{}
	feed, stop, err := s.PERSIST.InsertUsers(stream.Context())
	if err != nil {
		return err
	}
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		beforeRes, err := s.HOOKS.InsertUsersBeforeHook(req)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
		} else if beforeRes != nil {
			continue
		}
		params, err := UserToUServPersistType(s.MAPPINGS, req)
		if err != nil {
			return err
		}
		if err := feed(params); err != nil {
			return err
		}
	}
	row, err := stop()
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error receiving result row: %v", err)
	}
	if row != nil {
		res, err = EmptyFromUServDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			return err
		}
	}
	// NOTE: I dont want to store your requests in memory
	// so the after hook for client streaming calls
	// is called with an empty request struct
	fakeReq := &User{}
	if err := s.HOOKS.InsertUsersAfterHook(fakeReq, res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
	}
	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}
func (s *UServ_Impl) GetAllUsers(req *Empty, stream UServ_GetAllUsersServer) error {
	var err error
	_ = err
	beforeRes, err := s.HOOKS.GetAllUsersBeforeHook(req)
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
	} else if beforeRes != nil {
		for _, res := range beforeRes {
			if err := stream.Send(res); err != nil {
				return gstatus.Errorf(codes.Unknown, "error sending back before hook result: %v", err)
			}
		}
	}
	params, err := EmptyToUServPersistType(s.MAPPINGS, req)
	if err != nil {
		return err
	}
	var iterErr error
	err = s.PERSIST.GetAllUsers(stream.Context(), params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err := UserFromUServDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
		if err := s.HOOKS.GetAllUsersAfterHook(req, res); err != nil {
			iterErr = gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
			return
		}
		if err := stream.Send(res); err != nil {
			iterErr = gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
		}
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
	} else if iterErr != nil {
		return iterErr
	}
	return nil
}
func (s *UServ_Impl) SelectUserById(ctx context.Context, req *User) (*User, error) {
	var err error
	var res = &User{}
	_ = err
	_ = res
	params, err := UserToUServPersistType(s.MAPPINGS, req)
	if err != nil {
		return nil, err
	}
	var iterErr error
	err = s.PERSIST.SelectUserById(ctx, params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err = UserFromUServDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
	})
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error calling persist service: %v", err)
	} else if iterErr != nil {
		return nil, iterErr
	}
	return res, nil
}
func (s *UServ_Impl) UpdateUserNames(stream UServ_UpdateUserNamesServer) error {
	var err error
	_ = err
	feed, stop := s.PERSIST.UpdateUserNames(stream.Context())
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		params, err := UserToUServPersistType(s.MAPPINGS, req)
		if err != nil {
			return err
		}
		row, err := feed(params)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving result row: %v", err)
		}
		if row != nil {
			res, err := UserFromUServDatabaseRow(s.MAPPINGS, row)
			if err != nil {
				return err
			}
			if err := stream.Send(res); err != nil {
				return err
			}
		}
	}
	return stop()
}
func (s *UServ_Impl) UpdateNameToFoo(ctx context.Context, req *User) (*Empty, error) {
	var err error
	var res = &Empty{}
	_ = err
	_ = res
	params, err := UserToUServPersistType(s.MAPPINGS, req)
	if err != nil {
		return nil, err
	}
	var iterErr error
	err = s.PERSIST.UpdateNameToFoo(ctx, params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err = EmptyFromUServDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
	})
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error calling persist service: %v", err)
	} else if iterErr != nil {
		return nil, iterErr
	}
	return res, nil
}
func (s *UServ_Impl) UpdateAllNames(req *Empty, stream UServ_UpdateAllNamesServer) error {
	return s.FORWARDED.UpdateAllNames(req, stream)
}

// always return a result
// results have ability to iterate, and
func (s *UServ_Impl) GetFriends(req *FriendsReq, stream UServ_GetFriendsServer) error {
	var err error
	_ = err
	params, err := FriendsReqToUServPersistType(s.MAPPINGS, req)
	if err != nil {
		return err
	}
	var iterErr error
	err = s.PERSIST.GetFriends(stream.Context(), params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err := UserFromUServDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
		if err := stream.Send(res); err != nil {
			iterErr = gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
		}
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error during iteration: %v", err)
	} else if iterErr != nil {
		return iterErr
	}
	return nil
}
func (s *UServ_Impl) DropTable(ctx context.Context, req *Empty) (*Empty, error) {
	var err error
	var res = &Empty{}
	_ = err
	_ = res
	params, err := EmptyToUServPersistType(s.MAPPINGS, req)
	if err != nil {
		return nil, err
	}
	var iterErr error
	err = s.PERSIST.DropTable(ctx, params, func(row persist_lib.Scanable) {
		if row == nil { // there was no return data
			return
		}
		res, err = EmptyFromUServDatabaseRow(s.MAPPINGS, row)
		if err != nil {
			iterErr = err
			return
		}
	})
	if err != nil {
		return nil, gstatus.Errorf(codes.Unknown, "error calling persist service: %v", err)
	} else if iterErr != nil {
		return nil, iterErr
	}
	return res, nil
}
