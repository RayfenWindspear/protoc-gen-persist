// This file is generated by protoc-gen-persist
// Source File: examples/sql/basic/basic.proto
// DO NOT EDIT !
package basic

import (
	sql "database/sql"
	fmt "fmt"
	io "io"
	strings "strings"

	mytime "github.com/tcncloud/protoc-gen-persist/examples/mytime"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

type AmazingImpl struct {
	SqlDB *sql.DB
}

func NewAmazingImpl(driver, connString string) (*AmazingImpl, error) {
	db, err := sql.Open(driver, connString)
	if err != nil {
		return nil, err
	}
	return &AmazingImpl{SqlDB: db}, nil
}

// sql unary UniarySelect
func (s *AmazingImpl) UniarySelect(ctx context.Context, req *PartialTable) (*ExampleTable, error) {
	var (
		Id        int64
		Name      string
		StartTime mytime.MyTime
	)
	err := s.SqlDB.QueryRow("SELECT * from example_table Where id=$1 AND start_time=$2", req.Id, mytime.MyTime{}.ToSql(req.StartTime)).
		Scan(&Id, &StartTime, &Name)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, grpc.Errorf(codes.NotFound, "%+v doesn't exist", req)
		} else if strings.Contains(err.Error(), "duplicate key") {
			return nil, grpc.Errorf(codes.AlreadyExists, "%+v already exists")
		}
		return nil, grpc.Errorf(codes.Unknown, err.Error())
	}
	res := &ExampleTable{

		Id:        Id,
		Name:      Name,
		StartTime: StartTime.ToProto(),
	}
	return res, nil
}

// sql server streaming ServerStream
func (s *AmazingImpl) ServerStream(req *Name, stream Amazing_ServerStreamServer) error {
	var (
		Id        int64
		Name      string
		StartTime mytime.MyTime
	)
	rows, err := s.SqlDB.Query("SELECT * FROM example_table WHERE name=$1", req.Name)
	if err != nil {
		return grpc.Errorf(codes.Unknown, err.Error())
	}
	defer rows.Close()
	for rows.Next() {
		err = rows.Err()
		if err != nil {
			if err == sql.ErrNoRows {
				return grpc.Errorf(codes.NotFound, "%+v doesn't exist", req)
			} else if strings.Contains(err.Error(), "duplicate key") {
				return grpc.Errorf(codes.AlreadyExists, "%+v already exists")
			}
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		err := rows.Scan(&Id, &StartTime, &Name)
		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		res := &ExampleTable{

			Id:        Id,
			Name:      Name,
			StartTime: StartTime.ToProto(),
		}
		stream.Send(res)
	}
	return nil
}

// sql bidi streaming Bidirectional
func (s *AmazingImpl) Bidirectional(stream Amazing_BidirectionalServer) error {
	stmt, err := s.SqlDB.Prepare("UPDATE example_table SET (start_time, name) = ($2, $3) WHERE id=$1 RETURNING *")
	if err != nil {
		return err
	}
	defer stmt.Close()
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		var (
			Id        int64
			Name      string
			StartTime mytime.MyTime
		)
		err = stmt.QueryRow(req.Id, mytime.MyTime{}.ToSql(req.StartTime), req.Name).
			Scan(&Id, &StartTime, &Name)
		if err != nil {
			if err == sql.ErrNoRows {
				return grpc.Errorf(codes.NotFound, "%+v doesn't exist", req)
			} else if strings.Contains(err.Error(), "duplicate key") {
				return grpc.Errorf(codes.AlreadyExists, "%+v already exists")
			}
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		res := &ExampleTable{

			Id:        Id,
			Name:      Name,
			StartTime: StartTime.ToProto(),
		}
		if err := stream.Send(res); err != nil {
			return grpc.Errorf(codes.Unknown, err.Error())
		}
	}
	return nil
}

// sql client streaming ClientStream
func (s *AmazingImpl) ClientStream(stream Amazing_ClientStreamServer) error {
	stmt, err := s.SqlDB.Prepare("INSERT INTO example_table (id, start_time, name) VALUES ($1, $2, $3)")
	if err != nil {
		return err
	}
	tx, err := s.SqlDB.Begin()
	if err != nil {
		return err
	}
	totalAffected := int64(0)
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			tx.Rollback()
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		affected, err := tx.Stmt(stmt).Exec(req.Id, mytime.MyTime{}.ToSql(req.StartTime), req.Name)
		if err != nil {
			tx.Rollback()
			if err == sql.ErrNoRows {
				return grpc.Errorf(codes.NotFound, "%+v doesn't exist", req)
			} else if strings.Contains(err.Error(), "duplicate key") {
				return grpc.Errorf(codes.AlreadyExists, "%+v already exists")
			}
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		num, err := affected.RowsAffected()
		if err != nil {
			tx.Rollback()
			return grpc.Errorf(codes.Unknown, err.Error())
		}
		totalAffected += num
	}
	err = tx.Commit()
	if err != nil {
		fmt.Errorf("Commiting transaction failed, rolling back...")
		return grpc.Errorf(codes.Unknown, err.Error())
	}
	stream.SendAndClose(&NumRows{Count: totalAffected})
	return nil
}
