// This file is generated by protoc-gen-persist
// Source File: pb/user.proto
// DO NOT EDIT !
package pb

import (
	fmt "fmt"
	io "io"

	spanner "cloud.google.com/go/spanner"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	context "golang.org/x/net/context"
	iterator "google.golang.org/api/iterator"
	codes "google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

type PersistTx interface {
	Runnable
}
type Result interface {
	LastInsertId() (int64, error)
	RowsAffected() (int64, error)
}
type SpannerResult struct {
	// TODO shouldn't be an iter
	iter *spanner.RowIterator
}

func (sr *SpannerResult) LastInsertId() (int64, error) {
	// sr.iter.QueryStats or sr.iter.QueryPlan
	return -1, nil
}
func (sr *SpannerResult) RowsAffected() (int64, error) {
	// Execution statistics for the query. Available after RowIterator.Next returns iterator.Done
	return sr.iter.RowCount, nil
}

type Runnable interface {
	QueryWithStats(context.Context, spanner.Statement) *spanner.RowIterator
}

// UServ_Queries holds all the queries found the proto service option as methods
type UServ_Queries struct {
	opts UServ_Opts
}

// UServPersistQueries returns all the known 'SQL' queires for the 'UServ' service.
func UServPersistQueries(opts ...UServ_Opts) *UServ_Queries {
	var myOpts UServ_Opts
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = UServOpts(nil, nil)
	}
	return &UServ_Queries{
		opts: myOpts,
	}
}

// CreateUsersTableQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'create_users_table' on the database
// when executed
func (this *UServ_Queries) CreateUsersTable(ctx context.Context, db Runnable) *UServ_CreateUsersTableQuery {
	return &UServ_CreateUsersTableQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_CreateUsersTableQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_CreateUsersTableQuery) QueryInTypeUser()  {}
func (this *UServ_CreateUsersTableQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_CreateUsersTableQuery) Execute(x UServ_CreateUsersTableIn) *UServ_CreateUsersTableIter {
	ctx := this.ctx
	result := &UServ_CreateUsersTableIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "CREATE TABLE users(id integer PRIMARY KEY, name VARCHAR(50), friends BYTEA, created_on VARCHAR(50))",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// InsertUsersQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'insert_users' on the database
// when executed
func (this *UServ_Queries) InsertUsers(ctx context.Context, db Runnable) *UServ_InsertUsersQuery {
	return &UServ_InsertUsersQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_InsertUsersQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_InsertUsersQuery) QueryInTypeUser()  {}
func (this *UServ_InsertUsersQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_InsertUsersQuery) Execute(x UServ_InsertUsersIn) *UServ_InsertUsersIter {
	ctx := this.ctx
	result := &UServ_InsertUsersIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		result["name"] = x.GetName()
		friends, err := proto.Marshal(x.GetFriends())
		if err != nil {
			return nil, err
		}
		result["friends"] = friends
		created_on, err := this.opts.MAPPINGS.TimestampTimestamp().ToSpanner(x.GetCreatedOn()).SpannerValue()
		if err != nil {
			return nil, err
		}
		result["created_on"] = created_on

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "INSERT INTO users (id, name, friends, created_on) VALUES (@id, @name, @friends, @created_on)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// GetAllUsersQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'get_all_users' on the database
// when executed
func (this *UServ_Queries) GetAllUsers(ctx context.Context, db Runnable) *UServ_GetAllUsersQuery {
	return &UServ_GetAllUsersQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_GetAllUsersQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_GetAllUsersQuery) QueryInTypeUser()  {}
func (this *UServ_GetAllUsersQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_GetAllUsersQuery) Execute(x UServ_GetAllUsersIn) *UServ_GetAllUsersIter {
	ctx := this.ctx
	result := &UServ_GetAllUsersIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT id, name, friends, created_on FROM users",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// SelectUserByIdQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'select_user_by_id' on the database
// when executed
func (this *UServ_Queries) SelectUserById(ctx context.Context, db Runnable) *UServ_SelectUserByIdQuery {
	return &UServ_SelectUserByIdQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_SelectUserByIdQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_SelectUserByIdQuery) QueryInTypeUser()  {}
func (this *UServ_SelectUserByIdQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_SelectUserByIdQuery) Execute(x UServ_SelectUserByIdIn) *UServ_SelectUserByIdIter {
	ctx := this.ctx
	result := &UServ_SelectUserByIdIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT id, name, friends, created_on FROM users WHERE id = @id",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// UpdateUserNameQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'update_user_name' on the database
// when executed
func (this *UServ_Queries) UpdateUserName(ctx context.Context, db Runnable) *UServ_UpdateUserNameQuery {
	return &UServ_UpdateUserNameQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_UpdateUserNameQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_UpdateUserNameQuery) QueryInTypeUser()  {}
func (this *UServ_UpdateUserNameQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_UpdateUserNameQuery) Execute(x UServ_UpdateUserNameIn) *UServ_UpdateUserNameIter {
	ctx := this.ctx
	result := &UServ_UpdateUserNameIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["name"] = x.GetName()
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "Update users set name = @name PK(id = @id) ",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// UpdateNameToFooQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'update_name_to_foo' on the database
// when executed
func (this *UServ_Queries) UpdateNameToFoo(ctx context.Context, db Runnable) *UServ_UpdateNameToFooQuery {
	return &UServ_UpdateNameToFooQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_UpdateNameToFooQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_UpdateNameToFooQuery) QueryInTypeUser()  {}
func (this *UServ_UpdateNameToFooQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_UpdateNameToFooQuery) Execute(x UServ_UpdateNameToFooIn) *UServ_UpdateNameToFooIter {
	ctx := this.ctx
	result := &UServ_UpdateNameToFooIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		result["id"] = x.GetId()
		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "Update users set name = 'foo' PRIMARY_KEY(id = @id)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// GetFriendsQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'get_friends' on the database
// when executed
func (this *UServ_Queries) GetFriends(ctx context.Context, db Runnable) *UServ_GetFriendsQuery {
	return &UServ_GetFriendsQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_GetFriendsQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_GetFriendsQuery) QueryInTypeUser()  {}
func (this *UServ_GetFriendsQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_GetFriendsQuery) Execute(x UServ_GetFriendsIn) *UServ_GetFriendsIter {
	ctx := this.ctx
	result := &UServ_GetFriendsIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})
		names, err := this.opts.MAPPINGS.SliceStringParam().ToSpanner(x.GetNames()).SpannerValue()
		if err != nil {
			return nil, err
		}
		result["names"] = names

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "SELECT id, name, friends, created_on  FROM users WHERE name IN UNNEST(@names)",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

// DropQuery returns a new struct wrapping the current UServ_Opts
// that will perform 'UServ' services 'drop' on the database
// when executed
func (this *UServ_Queries) Drop(ctx context.Context, db Runnable) *UServ_DropQuery {
	return &UServ_DropQuery{
		opts: this.opts,
		ctx:  ctx,
		db:   db,
	}
}

type UServ_DropQuery struct {
	opts UServ_Opts
	db   Runnable
	ctx  context.Context
}

func (this *UServ_DropQuery) QueryInTypeUser()  {}
func (this *UServ_DropQuery) QueryOutTypeUser() {}

// Executes the query with parameters retrieved from x
func (this *UServ_DropQuery) Execute(x UServ_DropIn) *UServ_DropIter {
	ctx := this.ctx
	result := &UServ_DropIter{
		result: &SpannerResult{},
		tm:     this.opts.MAPPINGS,
		ctx:    ctx,
	}
	params, err := func() (map[string]interface{}, error) {
		result := make(map[string]interface{})

		return result, nil
	}()
	if err != nil {
		result.err = err
		return result
	}
	iter := this.db.QueryWithStats(ctx, spanner.Statement{
		SQL:    "drop table users",
		Params: params,
	})
	result.rows = iter
	result.err = err
	return result
}

type UServ_CreateUsersTableIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_CreateUsersTableIter) IterOutTypeEmpty() {}
func (this *UServ_CreateUsersTableIter) IterInTypeEmpty()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_CreateUsersTableIter) Each(fun func(*UServ_CreateUsersTableRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_CreateUsersTableIter) One() *UServ_CreateUsersTableRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_CreateUsersTableRow{err: fmt.Errorf("expected exactly 1 result from query 'CreateUsersTable' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_CreateUsersTableIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'CreateUsersTable'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_CreateUsersTableIter) Next() (*UServ_CreateUsersTableRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_CreateUsersTableRow{err: err}, true
	}
	res := &Empty{}
	return &UServ_CreateUsersTableRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_CreateUsersTableIter) Slice() []*UServ_CreateUsersTableRow {
	var results []*UServ_CreateUsersTableRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_InsertUsersIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_InsertUsersIter) IterOutTypeEmpty() {}
func (this *UServ_InsertUsersIter) IterInTypeUser()   {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_InsertUsersIter) Each(fun func(*UServ_InsertUsersRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_InsertUsersIter) One() *UServ_InsertUsersRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_InsertUsersRow{err: fmt.Errorf("expected exactly 1 result from query 'InsertUsers' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_InsertUsersIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'InsertUsers'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_InsertUsersIter) Next() (*UServ_InsertUsersRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_InsertUsersRow{err: err}, true
	}
	res := &Empty{}
	return &UServ_InsertUsersRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_InsertUsersIter) Slice() []*UServ_InsertUsersRow {
	var results []*UServ_InsertUsersRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_GetAllUsersIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_GetAllUsersIter) IterOutTypeUser() {}
func (this *UServ_GetAllUsersIter) IterInTypeEmpty() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_GetAllUsersIter) Each(fun func(*UServ_GetAllUsersRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_GetAllUsersIter) One() *UServ_GetAllUsersRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_GetAllUsersRow{err: fmt.Errorf("expected exactly 1 result from query 'GetAllUsers' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_GetAllUsersIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'GetAllUsers'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_GetAllUsersIter) Next() (*UServ_GetAllUsersRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_GetAllUsersRow{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &UServ_GetAllUsersRow{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &UServ_GetAllUsersRow{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &UServ_GetAllUsersRow{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &UServ_GetAllUsersRow{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &UServ_GetAllUsersRow{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp().Empty()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &UServ_GetAllUsersRow{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &UServ_GetAllUsersRow{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &UServ_GetAllUsersRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_GetAllUsersIter) Slice() []*UServ_GetAllUsersRow {
	var results []*UServ_GetAllUsersRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_SelectUserByIdIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_SelectUserByIdIter) IterOutTypeUser() {}
func (this *UServ_SelectUserByIdIter) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_SelectUserByIdIter) Each(fun func(*UServ_SelectUserByIdRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_SelectUserByIdIter) One() *UServ_SelectUserByIdRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("expected exactly 1 result from query 'SelectUserById' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_SelectUserByIdIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'SelectUserById'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_SelectUserByIdIter) Next() (*UServ_SelectUserByIdRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_SelectUserByIdRow{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp().Empty()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &UServ_SelectUserByIdRow{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &UServ_SelectUserByIdRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_SelectUserByIdIter) Slice() []*UServ_SelectUserByIdRow {
	var results []*UServ_SelectUserByIdRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_UpdateUserNameIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_UpdateUserNameIter) IterOutTypeUser() {}
func (this *UServ_UpdateUserNameIter) IterInTypeUser()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_UpdateUserNameIter) Each(fun func(*UServ_UpdateUserNameRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_UpdateUserNameIter) One() *UServ_UpdateUserNameRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("expected exactly 1 result from query 'UpdateUserName' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_UpdateUserNameIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UpdateUserName'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_UpdateUserNameIter) Next() (*UServ_UpdateUserNameRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_UpdateUserNameRow{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp().Empty()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &UServ_UpdateUserNameRow{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &UServ_UpdateUserNameRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_UpdateUserNameIter) Slice() []*UServ_UpdateUserNameRow {
	var results []*UServ_UpdateUserNameRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_UpdateNameToFooIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_UpdateNameToFooIter) IterOutTypeEmpty() {}
func (this *UServ_UpdateNameToFooIter) IterInTypeUser()   {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_UpdateNameToFooIter) Each(fun func(*UServ_UpdateNameToFooRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_UpdateNameToFooIter) One() *UServ_UpdateNameToFooRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_UpdateNameToFooRow{err: fmt.Errorf("expected exactly 1 result from query 'UpdateNameToFoo' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_UpdateNameToFooIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'UpdateNameToFoo'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_UpdateNameToFooIter) Next() (*UServ_UpdateNameToFooRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_UpdateNameToFooRow{err: err}, true
	}
	res := &Empty{}
	return &UServ_UpdateNameToFooRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_UpdateNameToFooIter) Slice() []*UServ_UpdateNameToFooRow {
	var results []*UServ_UpdateNameToFooRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_GetFriendsIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_GetFriendsIter) IterOutTypeUser()      {}
func (this *UServ_GetFriendsIter) IterInTypeFriendsReq() {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_GetFriendsIter) Each(fun func(*UServ_GetFriendsRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_GetFriendsIter) One() *UServ_GetFriendsRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_GetFriendsRow{err: fmt.Errorf("expected exactly 1 result from query 'GetFriends' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_GetFriendsIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'GetFriends'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_GetFriendsIter) Next() (*UServ_GetFriendsRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_GetFriendsRow{err: err}, true
	}
	var id int64
	if err := row.ColumnByName("id", &id); err != nil {
		return &UServ_GetFriendsRow{err: fmt.Errorf("cant convert db column id to protobuf go type int64")}, true
	}

	var name string
	if err := row.ColumnByName("name", &name); err != nil {
		return &UServ_GetFriendsRow{err: fmt.Errorf("cant convert db column name to protobuf go type string")}, true
	}

	friends := &Friends{}
	friendsBytes := make([]byte, 0)
	if err := row.ColumnByName("friends", &friendsBytes); err != nil {
		return &UServ_GetFriendsRow{err: fmt.Errorf("failed to convert db column friends to []byte")}, true
	}
	if err := proto.Unmarshal(friendsBytes, friends); err != nil {
		return &UServ_GetFriendsRow{err: fmt.Errorf("failed to unmarshal column friends to proto message")}, true
	}

	var created_on *timestamp.Timestamp
	var created_on_col spanner.GenericColumnValue
	if err := row.ColumnByName("created_on", &created_on_col); err != nil {
		return &UServ_GetFriendsRow{err: fmt.Errorf("failed to convert db column created_on to spanner.GenericColumnValue")}, true
	}
	convert_created_on := this.tm.TimestampTimestamp().Empty()
	if err := convert_created_on.SpannerScan(&created_on_col); err != nil {
		return &UServ_GetFriendsRow{err: fmt.Errorf("SpannerScan failed for created_on")}, true
	}
	if err := convert_created_on.ToProto(&created_on); err != nil {
		return &UServ_GetFriendsRow{err: fmt.Errorf("ToProto for created_on when reading from spanner")}, true
	}

	res := &User{
		Id:        id,
		Name:      name,
		Friends:   friends,
		CreatedOn: created_on,
	}
	return &UServ_GetFriendsRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_GetFriendsIter) Slice() []*UServ_GetFriendsRow {
	var results []*UServ_GetFriendsRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_DropIter struct {
	result *SpannerResult
	rows   *spanner.RowIterator
	err    error
	tm     UServ_TypeMappings
	ctx    context.Context
}

func (this *UServ_DropIter) IterOutTypeEmpty() {}
func (this *UServ_DropIter) IterInTypeEmpty()  {}

// Each performs 'fun' on each row in the result set.
// Each respects the context passed to it.
// It will stop iteration, and returns this.ctx.Err() if encountered.
func (this *UServ_DropIter) Each(fun func(*UServ_DropRow) error) error {
	for {
		select {
		case <-this.ctx.Done():
			return this.ctx.Err()
		default:
			if row, ok := this.Next(); !ok {
				return nil
			} else if err := fun(row); err != nil {
				return err
			}
		}
	}
}

// One returns the sole row, or ensures an error if there was not one result when this row is converted
func (this *UServ_DropIter) One() *UServ_DropRow {
	first, hasFirst := this.Next()
	_, hasSecond := this.Next()
	if !hasFirst || hasSecond {
		amount := "none"
		if hasSecond {
			amount = "multiple"
		}
		return &UServ_DropRow{err: fmt.Errorf("expected exactly 1 result from query 'Drop' found %s", amount)}
	}
	return first
}

// Zero returns an error if there were any rows in the result
func (this *UServ_DropIter) Zero() error {
	row, ok := this.Next()
	if row != nil && row.err != nil {
		return row.err
	}
	if ok {
		return fmt.Errorf("expected exactly 0 results from query 'Drop'")
	}
	return nil
}

// Next returns the next scanned row out of the database, or (nil, false) if there are no more rows
func (this *UServ_DropIter) Next() (*UServ_DropRow, bool) {
	row, err := this.rows.Next()
	_ = row
	if err == iterator.Done {
		return nil, false
	}
	if err != nil {
		return &UServ_DropRow{err: err}, true
	}
	res := &Empty{}
	return &UServ_DropRow{item: res}, true
}

// Slice returns all rows found in the iterator as a Slice.
func (this *UServ_DropIter) Slice() []*UServ_DropRow {
	var results []*UServ_DropRow
	for {
		if i, ok := this.Next(); ok {
			results = append(results, i)
		} else {
			break
		}
	}
	return results
}

type UServ_CreateUsersTableIn interface {
}
type UServ_CreateUsersTableOut interface {
}
type UServ_CreateUsersTableRow struct {
	item UServ_CreateUsersTableOut
	err  error
}

func newUServ_CreateUsersTableRow(item UServ_CreateUsersTableOut, err error) *UServ_CreateUsersTableRow {
	return &UServ_CreateUsersTableRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_CreateUsersTableRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *UServ_CreateUsersTableRow) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *UServ_CreateUsersTableRow) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type UServ_InsertUsersIn interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_InsertUsersOut interface {
}
type UServ_InsertUsersRow struct {
	item UServ_InsertUsersOut
	err  error
}

func newUServ_InsertUsersRow(item UServ_InsertUsersOut, err error) *UServ_InsertUsersRow {
	return &UServ_InsertUsersRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_InsertUsersRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *UServ_InsertUsersRow) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *UServ_InsertUsersRow) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type UServ_GetAllUsersIn interface {
}
type UServ_GetAllUsersOut interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_GetAllUsersRow struct {
	item UServ_GetAllUsersOut
	err  error
}

func newUServ_GetAllUsersRow(item UServ_GetAllUsersOut, err error) *UServ_GetAllUsersRow {
	return &UServ_GetAllUsersRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_GetAllUsersRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *UServ_GetAllUsersRow) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *UServ_GetAllUsersRow) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type UServ_SelectUserByIdIn interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_SelectUserByIdOut interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_SelectUserByIdRow struct {
	item UServ_SelectUserByIdOut
	err  error
}

func newUServ_SelectUserByIdRow(item UServ_SelectUserByIdOut, err error) *UServ_SelectUserByIdRow {
	return &UServ_SelectUserByIdRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_SelectUserByIdRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *UServ_SelectUserByIdRow) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *UServ_SelectUserByIdRow) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type UServ_UpdateUserNameIn interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_UpdateUserNameOut interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_UpdateUserNameRow struct {
	item UServ_UpdateUserNameOut
	err  error
}

func newUServ_UpdateUserNameRow(item UServ_UpdateUserNameOut, err error) *UServ_UpdateUserNameRow {
	return &UServ_UpdateUserNameRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_UpdateUserNameRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *UServ_UpdateUserNameRow) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *UServ_UpdateUserNameRow) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type UServ_UpdateNameToFooIn interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_UpdateNameToFooOut interface {
}
type UServ_UpdateNameToFooRow struct {
	item UServ_UpdateNameToFooOut
	err  error
}

func newUServ_UpdateNameToFooRow(item UServ_UpdateNameToFooOut, err error) *UServ_UpdateNameToFooRow {
	return &UServ_UpdateNameToFooRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_UpdateNameToFooRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *UServ_UpdateNameToFooRow) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *UServ_UpdateNameToFooRow) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type UServ_GetFriendsIn interface {
	GetNames() *SliceStringParam
}
type UServ_GetFriendsOut interface {
	GetId() int64
	GetName() string
	GetFriends() *Friends
	GetCreatedOn() *timestamp.Timestamp
}
type UServ_GetFriendsRow struct {
	item UServ_GetFriendsOut
	err  error
}

func newUServ_GetFriendsRow(item UServ_GetFriendsOut, err error) *UServ_GetFriendsRow {
	return &UServ_GetFriendsRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_GetFriendsRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*User); ok {
		if o == nil {
			return fmt.Errorf("must initialize *User before giving to Unwrap()")
		}
		res, _ := this.User()
		_ = res
		o.Id = res.Id
		o.Name = res.Name
		o.Friends = res.Friends
		o.CreatedOn = res.CreatedOn
		return nil
	}

	return nil
}
func (this *UServ_GetFriendsRow) User() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

func (this *UServ_GetFriendsRow) Proto() (*User, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &User{
		Id:        this.item.GetId(),
		Name:      this.item.GetName(),
		Friends:   this.item.GetFriends(),
		CreatedOn: this.item.GetCreatedOn(),
	}, nil
}

type UServ_DropIn interface {
}
type UServ_DropOut interface {
}
type UServ_DropRow struct {
	item UServ_DropOut
	err  error
}

func newUServ_DropRow(item UServ_DropOut, err error) *UServ_DropRow {
	return &UServ_DropRow{item, err}
}

// Unwrap takes an address to a proto.Message as its only parameter
// Unwrap can only set into output protos of that match method return types + the out option on the query itself
func (this *UServ_DropRow) Unwrap(pointerToMsg proto.Message) error {
	if this.err != nil {
		return this.err
	}
	if o, ok := (pointerToMsg).(*Empty); ok {
		if o == nil {
			return fmt.Errorf("must initialize *Empty before giving to Unwrap()")
		}
		res, _ := this.Empty()
		_ = res

		return nil
	}

	return nil
}
func (this *UServ_DropRow) Empty() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

func (this *UServ_DropRow) Proto() (*Empty, error) {
	if this.err != nil {
		return nil, this.err
	}
	return &Empty{}, nil
}

type UServ_Hooks interface {
	InsertUsersBeforeHook(context.Context, *User) (*Empty, error)
	GetAllUsersBeforeHook(context.Context, *Empty) (*User, error)
	InsertUsersAfterHook(context.Context, *User, *Empty) error
	GetAllUsersAfterHook(context.Context, *Empty, *User) error
}
type UServ_DefaultHooks struct{}

func (*UServ_DefaultHooks) InsertUsersBeforeHook(context.Context, *User) (*Empty, error) {
	return nil, nil
}
func (*UServ_DefaultHooks) GetAllUsersBeforeHook(context.Context, *Empty) (*User, error) {
	return nil, nil
}
func (*UServ_DefaultHooks) InsertUsersAfterHook(context.Context, *User, *Empty) error {
	return nil
}
func (*UServ_DefaultHooks) GetAllUsersAfterHook(context.Context, *Empty, *User) error {
	return nil
}

type UServ_TypeMappings interface {
	TimestampTimestamp() UServTimestampTimestampMappingImpl
	SliceStringParam() UServSliceStringParamMappingImpl
}
type UServ_DefaultTypeMappings struct{}

func (this *UServ_DefaultTypeMappings) TimestampTimestamp() UServTimestampTimestampMappingImpl {
	return &UServ_DefaultTimestampTimestampMappingImpl{}
}

type UServ_DefaultTimestampTimestampMappingImpl struct{}

func (this *UServ_DefaultTimestampTimestampMappingImpl) ToProto(**timestamp.Timestamp) error {
	return nil
}
func (this *UServ_DefaultTimestampTimestampMappingImpl) Empty() UServTimestampTimestampMappingImpl {
	return this
}
func (this *UServ_DefaultTimestampTimestampMappingImpl) ToSpanner(*timestamp.Timestamp) UServTimestampTimestampMappingImpl {
	return this
}
func (this *UServ_DefaultTimestampTimestampMappingImpl) SpannerScan(*spanner.GenericColumnValue) error {
	return nil
}
func (this *UServ_DefaultTimestampTimestampMappingImpl) SpannerValue() (interface{}, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type UServTimestampTimestampMappingImpl interface {
	ToProto(**timestamp.Timestamp) error
	Empty() UServTimestampTimestampMappingImpl
	ToSpanner(*timestamp.Timestamp) UServTimestampTimestampMappingImpl
	SpannerScan(*spanner.GenericColumnValue) error
	SpannerValue() (interface{}, error)
}

func (this *UServ_DefaultTypeMappings) SliceStringParam() UServSliceStringParamMappingImpl {
	return &UServ_DefaultSliceStringParamMappingImpl{}
}

type UServ_DefaultSliceStringParamMappingImpl struct{}

func (this *UServ_DefaultSliceStringParamMappingImpl) ToProto(**SliceStringParam) error {
	return nil
}
func (this *UServ_DefaultSliceStringParamMappingImpl) Empty() UServSliceStringParamMappingImpl {
	return this
}
func (this *UServ_DefaultSliceStringParamMappingImpl) ToSpanner(*SliceStringParam) UServSliceStringParamMappingImpl {
	return this
}
func (this *UServ_DefaultSliceStringParamMappingImpl) SpannerScan(*spanner.GenericColumnValue) error {
	return nil
}
func (this *UServ_DefaultSliceStringParamMappingImpl) SpannerValue() (interface{}, error) {
	return "DEFAULT_TYPE_MAPPING_VALUE", nil
}

type UServSliceStringParamMappingImpl interface {
	ToProto(**SliceStringParam) error
	Empty() UServSliceStringParamMappingImpl
	ToSpanner(*SliceStringParam) UServSliceStringParamMappingImpl
	SpannerScan(*spanner.GenericColumnValue) error
	SpannerValue() (interface{}, error)
}
type UServ_Opts struct {
	MAPPINGS UServ_TypeMappings
	HOOKS    UServ_Hooks
}

func UServOpts(hooks UServ_Hooks, mappings UServ_TypeMappings) UServ_Opts {
	opts := UServ_Opts{
		HOOKS:    &UServ_DefaultHooks{},
		MAPPINGS: &UServ_DefaultTypeMappings{},
	}
	if hooks != nil {
		opts.HOOKS = hooks
	}
	if mappings != nil {
		opts.MAPPINGS = mappings
	}
	return opts
}

type UServ_Impl struct {
	opts     *UServ_Opts
	QUERIES  *UServ_Queries
	HANDLERS RestOfUServHandlers
	DB       *spanner.Client
}

func UServPersistImpl(db *spanner.Client, handlers RestOfUServHandlers, opts ...UServ_Opts) *UServ_Impl {
	var myOpts UServ_Opts
	if len(opts) > 0 {
		myOpts = opts[0]
	} else {
		myOpts = UServOpts(nil, nil)
	}
	return &UServ_Impl{
		opts:     &myOpts,
		QUERIES:  UServPersistQueries(myOpts),
		DB:       db,
		HANDLERS: handlers,
	}
}

type RestOfUServHandlers interface {
	UpdateUserNames(UServ_UpdateUserNamesServer) error
	UpdateAllNames(*Empty, UServ_UpdateAllNamesServer) error
}

func (this *UServ_Impl) UpdateUserNames(stream UServ_UpdateUserNamesServer) error {
	return this.HANDLERS.UpdateUserNames(stream)
}

func (this *UServ_Impl) UpdateAllNames(req *Empty, stream UServ_UpdateAllNamesServer) error {
	return this.HANDLERS.UpdateAllNames(req, stream)
}

func (this *UServ_Impl) CreateTable(ctx context.Context, req *Empty) (*Empty, error) {
	query := this.QUERIES.CreateUsersTable(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *UServ_Impl) InsertUsers(stream UServ_InsertUsersServer) error {
	if err := this.InsertUsersTx(stream); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'insert_users' query: %v", err)
	}
	return nil
}
func (this *UServ_Impl) InsertUsersTx(stream UServ_InsertUsersServer) error {
	items := make([]*User, 0)
	var first *User
	for {
		req, err := stream.Recv()
		if err == io.EOF {
			break
		} else if err != nil {
			return gstatus.Errorf(codes.Unknown, "error receiving request: %v", err)
		}
		if first == nil {
			first = req
		}

		beforeRes, err := this.opts.HOOKS.InsertUsersBeforeHook(stream.Context(), req)
		if err != nil {
			return gstatus.Errorf(codes.Unknown, "error in before hook: %v", err)
		} else if beforeRes != nil {
			continue
		}

		items = append(items, req)
	}
	_, err := this.DB.ReadWriteTransaction(stream.Context(), func(ctx context.Context, tx *spanner.ReadWriteTransaction) error {
		for _, item := range items {
			query := this.QUERIES.InsertUsers(ctx, tx)
			result := query.Execute(item)
			if err := result.Zero(); err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return gstatus.Errorf(codes.Unknown, "error in read write transaction: %v", err)
	}
	res := &Empty{}

	if err := this.opts.HOOKS.InsertUsersAfterHook(stream.Context(), first, res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error in after hook: %v", err)
	}

	if err := stream.SendAndClose(res); err != nil {
		return gstatus.Errorf(codes.Unknown, "error sending back response: %v", err)
	}
	return nil
}

func (this *UServ_Impl) GetAllUsers(req *Empty, stream UServ_GetAllUsersServer) error {
	if err := this.GetAllUsersTx(req, stream, this.DB.Single()); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'get_all_users' query: %v", err)
	}
	return nil
}
func (this *UServ_Impl) GetAllUsersTx(req *Empty, stream UServ_GetAllUsersServer, tx PersistTx) error {
	ctx := stream.Context()
	query := this.QUERIES.GetAllUsers(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *UServ_GetAllUsersRow) error {
		res, err := row.User()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *UServ_Impl) SelectUserById(ctx context.Context, req *User) (*User, error) {
	query := this.QUERIES.SelectUserById(ctx, this.DB.Single())

	result := query.Execute(req)
	res, err := result.One().User()
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *UServ_Impl) UpdateNameToFoo(ctx context.Context, req *User) (*Empty, error) {
	query := this.QUERIES.UpdateNameToFoo(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}

func (this *UServ_Impl) GetFriends(req *FriendsReq, stream UServ_GetFriendsServer) error {
	if err := this.GetFriendsTx(req, stream, this.DB.Single()); err != nil {
		return gstatus.Errorf(codes.Unknown, "error executing 'get_friends' query: %v", err)
	}
	return nil
}
func (this *UServ_Impl) GetFriendsTx(req *FriendsReq, stream UServ_GetFriendsServer, tx PersistTx) error {
	ctx := stream.Context()
	query := this.QUERIES.GetFriends(ctx, tx)
	iter := query.Execute(req)
	return iter.Each(func(row *UServ_GetFriendsRow) error {
		res, err := row.User()
		if err != nil {
			return err
		}
		return stream.Send(res)
	})
}

func (this *UServ_Impl) DropTable(ctx context.Context, req *Empty) (*Empty, error) {
	query := this.QUERIES.Drop(ctx, this.DB.Single())

	result := query.Execute(req)

	err := result.Zero()
	res := &Empty{}

	if err != nil {
		return nil, err
	}

	return res, nil
}
