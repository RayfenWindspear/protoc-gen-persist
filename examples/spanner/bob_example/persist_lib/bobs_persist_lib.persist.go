// This file is generated by protoc-gen-persist
// Source File: examples/spanner/bob_example/bobs.proto
// DO NOT EDIT
package persist_lib

import (
	"cloud.google.com/go/spanner"
	"golang.org/x/net/context"
)

type BobsPersistHelper struct {
	Handlers BobsHandlers
}
type BobsHandlers struct {
	DeleteBobsHandler         func(context.Context, *BobInput, func(*spanner.Row)) error
	PutBobsHandler            func(context.Context) (func(*BobInput), func() (*spanner.Row, error))
	GetBobsHandler            func(context.Context, *EmptyInput, func(*spanner.Row)) error
	GetPeopleFromNamesHandler func(context.Context, *NamesInput, func(*spanner.Row)) error
}

// handler implementation
// next must be called on each result row
func (p *BobsPersistHelper) DeleteBobs(ctx context.Context, params *BobInput, next func(*spanner.Row)) error {
	return p.Handlers.DeleteBobsHandler(ctx, params, next)
}

// given a context, returns two functions.  (feed, stop)
// feed will be called once for every row recieved by the handler
// stop will be called when the client is done streaming. it expects
//a  *spanner.Row to be returned, or nil.
func (p *BobsPersistHelper) PutBobs(ctx context.Context) (func(*BobInput), func() (*spanner.Row, error)) {
	return p.Handlers.PutBobsHandler(ctx)
}

// next must be called on each result row
func (p *BobsPersistHelper) GetBobs(ctx context.Context, params *EmptyInput, next func(*spanner.Row)) error {
	return p.Handlers.GetBobsHandler(ctx, params, next)
}

// next must be called on each result row
func (p *BobsPersistHelper) GetPeopleFromNames(ctx context.Context, params *NamesInput, next func(*spanner.Row)) error {
	return p.Handlers.GetPeopleFromNamesHandler(ctx, params, next)
}

// input type definitions
type BobInput struct {
	Id        int64
	StartTime interface{}
	Name      string
}
type EmptyInput struct {
}
type NamesInput struct {
	Names []string
}

// all our queries represented as spanner functions or mutations
func BobFromDeleteBobsQuery(req *BobInput) *spanner.Mutation {
	return spanner.Delete("bob_table", spanner.KeyRange{
		Start: spanner.Key{
			"Bob",
		},
		End: spanner.Key{
			"Bob",
			req.StartTime,
		},
		Kind: spanner.ClosedOpen,
	})
}
func BobFromPutBobsQuery(req *BobInput) *spanner.Mutation {
	return spanner.InsertMap("bob_table", map[string]interface{}{
		"id":         req.Id,
		"name":       req.Name,
		"start_time": req.StartTime,
	})
}
func EmptyFromGetBobsQuery(req *EmptyInput) spanner.Statement {
	return spanner.Statement{
		SQL:    "SELECT * from bob_table",
		Params: map[string]interface{}{},
	}
}
func NamesFromGetPeopleFromNamesQuery(req *NamesInput) spanner.Statement {
	return spanner.Statement{
		SQL: "SELECT * FROM bob_table WHERE name IN UNNEST(@names)",
		Params: map[string]interface{}{
			"@names": req.Names,
		},
	}
}

// Default method implementations
func DefaultDeleteBobsHandler(cli *spanner.Client) func(context.Context, *BobInput, func(*spanner.Row)) error {
	return func(ctx context.Context, req *BobInput, next func(*spanner.Row)) error {
		if _, err := cli.Apply(ctx, []*spanner.Mutation{BobFromDeleteBobsQuery(req)}); err != nil {
			return err
		}
		next(nil) // this is an apply, it has no result
		return nil
	}
}
func DefaultPutBobsHandler(cli *spanner.Client) func(context.Context) (func(*BobInput), func() (*spanner.Row, error)) {
	return func(ctx context.Context) (func(*BobInput), func() (*spanner.Row, error)) {
		var muts []*spanner.Mutation
		feed := func(req *BobInput) {
			muts = append(muts, BobFromPutBobsQuery(req))
		}
		done := func() (*spanner.Row, error) {
			if _, err := cli.Apply(ctx, muts); err != nil {
				return nil, err
			}
			return nil, nil // we dont have a row, because we are an apply
		}
		return feed, done
	}
}
func DefaultGetBobsHandler(cli *spanner.Client) func(context.Context, *EmptyInput, func(*spanner.Row)) error {
	return func(ctx context.Context, req *EmptyInput, next func(*spanner.Row)) error {
		iter := cli.Single().Query(ctx, EmptyFromGetBobsQuery(req))
		if err := iter.Do(func(r *spanner.Row) error {
			next(r)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}
}
func DefaultGetPeopleFromNamesHandler(cli *spanner.Client) func(context.Context, *NamesInput, func(*spanner.Row)) error {
	return func(ctx context.Context, req *NamesInput, next func(*spanner.Row)) error {
		iter := cli.Single().Query(ctx, NamesFromGetPeopleFromNamesQuery(req))
		if err := iter.Do(func(r *spanner.Row) error {
			next(r)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}
}
