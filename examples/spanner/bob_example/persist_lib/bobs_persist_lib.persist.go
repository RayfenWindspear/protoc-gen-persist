// This file is generated by protoc-gen-persist
// Source File: examples/spanner/bob_example/bobs.proto
// DO NOT EDIT
package persist_lib

import (
	"cloud.google.com/go/spanner"
	"golang.org/x/net/context"
)

type BobsPersistHelper struct {
	Handlers BobsHandlers
}
type BobsHandlers interface {
	GetDeleteBobsHandler() func(context.Context, *BobsDeleteBobsInput, func(*spanner.Row)) error
	GetPutBobsHandler() func(context.Context) (func(*BobsPutBobsInput), func() (*spanner.Row, error))
	GetGetBobsHandler() func(context.Context, *BobsGetBobsInput, func(*spanner.Row)) error
	GetGetPeopleFromNamesHandler() func(context.Context, *BobsGetPeopleFromNamesInput, func(*spanner.Row)) error
}

func (p *BobsPersistHelper) DeleteBobs(ctx context.Context, params *BobsDeleteBobsInput, fn func(row *spanner.Row)) error {
	return p.Handlers.GetDeleteBobsHandler()(ctx, params, fn)
}

// given a context, returns two functions.  (feed, stop)
// feed will be called once for every row recieved by the handler
// stop will be called when the client is done streaming it expects some sort of results to be returned
// that can be marshalled into a response
func (p *BobsPersistHelper) PutBobs(ctx context.Context) (func(*BobsPutBobsInput), func() (*spanner.Row, error)) {
	return p.Handlers.GetPutBobsHandler()(ctx)
}
func (p *BobsPersistHelper) GetBobs(ctx context.Context, params *BobsGetBobsInput, fn func(row *spanner.Row)) error {
	return p.Handlers.GetGetBobsHandler()(ctx, params, fn)
}
func (p *BobsPersistHelper) GetPeopleFromNames(ctx context.Context, params *BobsGetPeopleFromNamesInput, fn func(row *spanner.Row)) error {
	return p.Handlers.GetGetPeopleFromNamesHandler()(ctx, params, fn)
}

// input type definitions
type BobsDeleteBobsInput struct {
	StartTime interface{}
}
type BobsPutBobsInput struct {
	Id        int64
	Name      string
	StartTime interface{}
}
type BobsGetBobsInput struct {
}
type BobsGetPeopleFromNamesInput struct {
	Names []string
}

func BobForDeleteBobs(req *BobsDeleteBobsInput) *spanner.Mutation {
	return spanner.Delete("bob_table", spanner.KeyRange{
		Start: spanner.Key{
			"Bob",
		},
		End: spanner.Key{
			"Bob",
			req.StartTime,
		},
		Kind: spanner.ClosedOpen,
	})
}
func BobForPutBobs(req *BobsPutBobsInput) *spanner.Mutation {
	return spanner.InsertMap("bob_table", map[string]interface{}{
		"start_time": req.StartTime,
		"id":         req.Id,
		"name":       req.Name,
	})
}
func EmptyForGetBobs(req *BobsGetBobsInput) spanner.Statement {
	return spanner.Statement{
		SQL:    "SELECT * from bob_table",
		Params: map[string]interface{}{},
	}
}
func NamesForGetPeopleFromNames(req *BobsGetPeopleFromNamesInput) spanner.Statement {
	return spanner.Statement{
		SQL: "SELECT * FROM bob_table WHERE name IN UNNEST(@names)",
		Params: map[string]interface{}{
			"@names": req.Names,
		},
	}
}

// Default method implementations
func DefaultDeleteBobsHandler(cli *spanner.Client) func(context.Context, *BobsDeleteBobsInput, func(*spanner.Row)) error {
	return func(ctx context.Context, req *BobsDeleteBobsInput, next func(*spanner.Row)) error {
		if _, err := cli.Apply(ctx, []*spanner.Mutation{BobForDeleteBobs(req)}); err != nil {
			return err
		}
		next(nil) // this is an apply, it has no result
		return nil
	}
}

func DefaultPutBobsHandler(cli *spanner.Client) func(context.Context) (func(*BobsPutBobsInput), func() (*spanner.Row, error)) {
	return func(ctx context.Context) (feed func(*BobsPutBobsInput), done func() (*spanner.Row, error)) {
		var muts []*spanner.Mutation
		feed = func(req *BobsPutBobsInput) {
			muts = append(muts, BobForPutBobs(req))
		}
		done = func() (*spanner.Row, error) {
			if _, err := cli.Apply(ctx, muts); err != nil {
				return nil, err
			}
			return nil, nil // we dont have a row, because we are an apply
		}
		return feed, done
	}
}

func DefaultGetBobsHandler(cli *spanner.Client) func(context.Context, *BobsGetBobsInput, func(*spanner.Row)) error {
	return func(ctx context.Context, req *BobsGetBobsInput, next func(*spanner.Row)) error {
		iter := cli.Single().Query(ctx, EmptyForGetBobs(req))
		if err := iter.Do(func(r *spanner.Row) error {
			next(r)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}
}

func DefaultGetPeopleFromNamesHandler(cli *spanner.Client) func(context.Context, *BobsGetPeopleFromNamesInput, func(*spanner.Row)) error {
	return func(ctx context.Context, req *BobsGetPeopleFromNamesInput, next func(*spanner.Row)) error {
		iter := cli.Single().Query(ctx, NamesForGetPeopleFromNames(req))
		if err := iter.Do(func(r *spanner.Row) error {
			next(r)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}
}
