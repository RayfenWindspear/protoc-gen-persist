# protoc-gen-persist

Protobuf plugin that generate a persistence layer backed by SQL or Spanner database

## NOTE: This project is under development everything could be changed !

## Rationale
Opinionated protoc plugin that will help generate builerplate go code for grpc microservices that need to interact 
with a SQL or Spanner database.


protoc-gen-persist is a protoc plugin used to generate golang CRUD services that communicate through GRPC,                     and talk to a persistence layer back end.  This is accomplished by providing a protobuf file with proper                       
annotations, and then running the protoc cli tool with the ```--go_out``` option, and the ```--persist_out```                 
options set to the same directory.

## Installation

## Documentation

## Versions


## Description
protoc-gen-persist is a protoc plugin used to generate golang CRUD services that communicate through GRPC,
and talk to a persistence layer back end.  This is accomplished by providing a protobuf file with proper
annotations, and then running the protoc cli tool with the ```--go_out``` option, and the ```--persist_out```
options set to the same directory.

What is generated is a when running protoc with the ```persist_out``` option is grpc functions that parse your
grpc requests, and perform the provided query on the database with using the request as parameters.  The result
of the query is then marshaled into your grpc response type and returned. So as a simple example, if you had
the proto file "simple_service.proto":

```protobuf
// we only support proto3 syntax
syntax = "proto3";

package simple_example;

import "github.com/tcncloud/protoc-gen-persist/persist/options.proto";

// a User is row our database's user table
message User {
  int64 id = 1;
  string first_name = 2;
  string last_name = 3;
}

message Id {
  int64 id = 1;
}

service UsersTalker {
  // for this example we will be using a SQL back end instead of a SPANNER back end
  option (persist.service_type) = SQL;

  // we will provide through grpc an Id, and expect back a User
  rpc SelectById(Id) returns (User) {
    option (persist.ql) = {
      // the query to run,  and the arguments to use. ?  will be replaced with the "id" field of the request
      query: "SELECT * from users WHERE id=? LIMIT 1"
      arguments: ["id"]
    };
  };
}
```
run the protoc commands (in the directory with the proto file):
- ```protoc -I/usr/local/include -I. -I$GOPATH/src --go_out=plugins=grpc:. ./simple_service.proto```
- ```protoc -I/usr/local/include -I. -I$GOPATH/src --persist_out=plugins=protoc-gen-persist:. ./simple_service.proto```

two new files (per proto file)  will be generated:
- simple_service.pb.go (from your --go_out command)
- simple_service.persist.go (from --persist_out command)

the .pb.go file will have your grpc service definition, and all the go types for your proto message definitions.
the .persist.go wil have your database handlers, and service implementation for talking with your persistence layer.
This example would generate a simple_service.persist.go file that looks like this:
```go
// This file is generated by protoc-gen-persist
// Source File: simple_service.proto
// DO NOT EDIT !
package simple_example

import (
	sql "database/sql"
	strings "strings"

	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

type UsersTalkerImpl struct {
	SqlDB *sql.DB
}

func NewUsersTalkerImpl(driver, connString string) (*UsersTalkerImpl, error) {
	db, err := sql.Open(driver, connString)
	if err != nil {
		return nil, err
	}
	return &UsersTalkerImpl{SqlDB: db}, nil
}

// sql unary SelectById
func (s *UsersTalkerImpl) SelectById(ctx context.Context, req *Id) (*User, error) {
	var (
		FirstName string
		Id        int64
		LastName  string
	)
	err := s.SqlDB.QueryRow("SELECT * from users WHERE id=? LIMIT 1", req.Id).
		Scan(&Id, &FirstName, &LastName)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, grpc.Errorf(codes.NotFound, "%+v doesn't exist", req)
		} else if strings.Contains(err.Error(), "duplicate key") {
			return nil, grpc.Errorf(codes.AlreadyExists, "%+v already exists")
		}
		return nil, grpc.Errorf(codes.Unknown, err.Error())
	}
	res := &User{

		FirstName: FirstName,
		Id:        Id,
		LastName:  LastName,
	}
	return res, nil
}
```

All that is left to do is to attach a "UsersTalkerImpl" to a grpc service and run it.
Here is a simple example of one way you could do that assuming you are using a vendor directory:
```go
package main

import (
	"fmt"
	"net"
	_"github.com/go-sql-driver/mysql"
	pb "simple_service"
	"google.golang.org/grpc"
)


func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		panic(err)
	}
	grpcServer := grpc.NewServer()
	s, err := pb.NewUsersTalkerImpl("mysql", "user:password@/dbname")
	if err != nil {
		panic(err)
	}
	pb.RegisterUsersTalkerServer(grpcServer, s)
	fmt.Printf("server listening on 50051\n")
	grpcServer.Serve(lis)
}
```

That is it.  you simply build, and run your server, and you will be able to make a grpc client
that can talk to your grpc server, and get users when given ids.

More complicated examples can be found in the examples directory

## Roadmap
 1. ~~type mapping~~
 1. before & after callback function
 1. add tests, lots of tests
 1. mongo


## Authors
 * Florin Stan (@namtzigla)
 * Neal Cooper (@iamneal)


## License
Copyright 2017, TCN Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

 * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
 * Neither the name of TCN Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
